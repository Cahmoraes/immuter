{"version":3,"sources":["../src/immuter/clone-handlers/clone-handler.ts","../src/immuter/shared/type-check.ts","../src/immuter/clone-handlers/array-clone-handler.ts","../src/immuter/clone-handlers/date-clone-handler.ts","../src/immuter/shared/errors/clone-exception-error.ts","../src/immuter/shared/clone-recursively.ts","../src/immuter/clone-handlers/object-clone-handler.ts","../src/immuter/clone-handlers/map-clone-handler.ts","../src/immuter/clone-handlers/set-clone-handler.ts","../src/immuter/services/clone-service.ts","../src/immuter/freeze-handlers/freeze-handler.ts","../src/immuter/freeze-handlers/array-freeze-handler.ts","../src/immuter/shared/errors/cannot-assign-to-immutable-map-error.ts","../src/immuter/freeze-handlers/map-freeze-handler.ts","../src/immuter/freeze-handlers/object-freeze-handler.ts","../src/immuter/shared/errors/cannot-assign-to-immutable-set-error.ts","../src/immuter/freeze-handlers/set-freeze-handler.ts","../src/immuter/freeze-handlers/date-clone-handler.ts","../src/immuter/services/freeze-service.ts","../src/immuter/services/produce-service.ts","../src/immuter/index.ts"],"names":["CloneHandler","aHandler","aType","cloneRecursively","TypeCheck","typeString","ArrayCloneHandler","DateCloneHandler","CloneExceptionError","message","CloneRecursively","aBaseStateCloned","strategyRecursively","error","aStrategyRecursively","objectToClone","descriptors","descriptor","aBaseState","ObjectCloneHandler","cloneServiceExecute","MapCloneHandler","aMap","newMap","value","key","SetCloneHandler","aSet","newSet","CloneService","objectCloneHandler","arrayCloneHandler","mapCloneHandler","setCloneHandler","dateCloneHandler","FreezeHandler","ArrayFreezeHandler","freezeServiceExecute","freezeRecursively","CannotAssignToImmutableMapError","MapFreezeHandler","ObjectFreezeHandler","CannotAssignToImmutableSetError","SetFreezeHandler","DateFreezeHandler","FreezeService","setFreezeHandler","mapFreezeHandler","objectFreezeHandler","arrayFreezeHandler","dateFreezeHandler","ProduceService","draftState","producer","initialState","_Immuter","config","aProducer","aDraftState","produce","Immuter"],"mappings":"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","sourcesContent":["export type CloneServiceExecuteCallback<Type> = (baseState: Type) => Type\n\nexport abstract class CloneHandler<Type = unknown> {\n  private next?: CloneHandler<Type>\n\n  constructor(aHandler?: CloneHandler<Type>) {\n    this.next = aHandler\n  }\n\n  public abstract handle(\n    aType: Type,\n    cloneServiceExecute: CloneServiceExecuteCallback<Type>,\n  ): Type\n\n  protected handleNext(\n    aType: Type,\n    cloneRecursively: CloneServiceExecuteCallback<Type>,\n  ): Type {\n    if (this.next) {\n      return this.next.handle(aType, cloneRecursively)\n    }\n    return aType\n  }\n}\n","export class TypeCheck {\n  private static check(aType: unknown): string {\n    const typeString = Reflect.apply(Object.prototype.toString, aType, [])\n    return typeString\n      .slice(typeString.indexOf(' ') + 1, typeString.indexOf(']'))\n      .toLowerCase()\n  }\n\n  static isDate(aType: unknown): aType is Date {\n    return this.check(aType) === 'date'\n  }\n\n  static isObject(aType: unknown): aType is object {\n    return this.check(aType) === 'object'\n  }\n\n  static isArray(aType: unknown): aType is unknown[] {\n    return Array.isArray(aType)\n  }\n\n  static isMap(aType: unknown): aType is Map<unknown, unknown> {\n    return this.check(aType) === 'map'\n  }\n\n  static isSet(aType: unknown): aType is Set<unknown> {\n    return this.check(aType) === 'set'\n  }\n}\n","import { CloneHandler, CloneServiceExecuteCallback } from './clone-handler'\nimport { TypeCheck } from '../shared/type-check'\n\nexport class ArrayCloneHandler extends CloneHandler {\n  public handle(\n    aType: unknown,\n    cloneRecursively: CloneServiceExecuteCallback<unknown>,\n  ): unknown {\n    if (TypeCheck.isArray(aType)) {\n      return this.createCloneOf(aType, cloneRecursively)\n    }\n    return this.handleNext(aType, cloneRecursively)\n  }\n\n  private createCloneOf(\n    aType: unknown[],\n    cloneRecursively: CloneServiceExecuteCallback<unknown>,\n  ): unknown[] {\n    return aType.map(cloneRecursively)\n  }\n}\n","import { CloneHandler, CloneServiceExecuteCallback } from './clone-handler'\nimport { TypeCheck } from '../shared/type-check'\n\nexport class DateCloneHandler extends CloneHandler {\n  public handle<TBaseState>(\n    aType: TBaseState,\n    cloneRecursively: CloneServiceExecuteCallback<unknown>,\n  ) {\n    if (TypeCheck.isDate(aType)) {\n      return new Date(aType)\n    }\n    return this.handleNext(aType, cloneRecursively)\n  }\n}\n","export class CloneExceptionError extends Error {\n  constructor(message: string) {\n    super(message)\n    this.name = 'CloneExceptionError'\n  }\n}\n","import { CloneExceptionError } from './errors/clone-exception-error'\r\n\r\ntype CloneServiceExecuteCallback<Type> = (baseState: Type) => Type\r\n\r\ntype TypedPropertyDescriptorOf<TBaseState> = {\r\n  [P in keyof TBaseState]: TypedPropertyDescriptor<TBaseState[P]>\r\n} & {\r\n  [x: string]: PropertyDescriptor\r\n}\r\n\r\nexport class CloneRecursively {\r\n  public static execute(\r\n    aBaseStateCloned: object,\r\n    strategyRecursively: CloneServiceExecuteCallback<unknown>,\r\n  ) {\r\n    try {\r\n      return this.performClone(aBaseStateCloned, strategyRecursively)\r\n    } catch (error) {\r\n      if (error instanceof Error) throw new CloneExceptionError(error.message)\r\n    }\r\n  }\r\n\r\n  private static performClone(\r\n    aBaseStateCloned: object,\r\n    aStrategyRecursively: CloneServiceExecuteCallback<unknown>,\r\n  ) {\r\n    const objectToClone = this.createCloneOf(aBaseStateCloned)\r\n    const descriptors = this.propertyDescriptorsOf(aBaseStateCloned)\r\n    for (const descriptor of Reflect.ownKeys(descriptors)) {\r\n      if (this.isEligibleToAssign(descriptors, descriptor)) {\r\n        objectToClone[descriptor] = aStrategyRecursively(\r\n          Reflect.get(objectToClone, descriptor),\r\n        )\r\n      }\r\n    }\r\n    return objectToClone\r\n  }\r\n\r\n  private static createCloneOf<TBaseState>(aBaseState: TBaseState) {\r\n    return Object.create(\r\n      this.prototypeOf(aBaseState),\r\n      this.propertyDescriptorsOf(aBaseState),\r\n    )\r\n  }\r\n\r\n  private static prototypeOf<TBaseState>(aBaseState: TBaseState) {\r\n    return Object.getPrototypeOf(aBaseState)\r\n  }\r\n\r\n  private static propertyDescriptorsOf<TBaseState>(aBaseState: TBaseState) {\r\n    return Object.getOwnPropertyDescriptors(aBaseState)\r\n  }\r\n\r\n  private static isEligibleToAssign<TBaseState>(\r\n    descriptors: TypedPropertyDescriptorOf<TBaseState>,\r\n    descriptor: keyof TBaseState | string | symbol,\r\n  ): descriptor is keyof TBaseState {\r\n    return (\r\n      descriptors[String(descriptor)] &&\r\n      Reflect.has(descriptors[String(descriptor)], 'value')\r\n    )\r\n  }\r\n}\r\n","import { CloneHandler, CloneServiceExecuteCallback } from './clone-handler'\nimport { TypeCheck } from '../shared/type-check'\nimport { CloneRecursively } from '../shared/clone-recursively'\n\nexport class ObjectCloneHandler extends CloneHandler {\n  public handle(\n    aType: unknown,\n    cloneServiceExecute: CloneServiceExecuteCallback<unknown>,\n  ) {\n    if (TypeCheck.isObject(aType)) {\n      return CloneRecursively.execute(aType, cloneServiceExecute)\n    }\n    return this.handleNext(aType, cloneServiceExecute)\n  }\n}\n","import { CloneHandler, CloneServiceExecuteCallback } from './clone-handler'\nimport { TypeCheck } from '../shared/type-check'\n\nexport class MapCloneHandler extends CloneHandler {\n  public handle(\n    aType: unknown,\n    cloneServiceExecute: CloneServiceExecuteCallback<unknown>,\n  ): unknown {\n    if (TypeCheck.isMap(aType)) {\n      return this.createCloneOf(aType, cloneServiceExecute)\n    }\n    return this.handleNext(aType, cloneServiceExecute)\n  }\n\n  private createCloneOf(\n    aMap: Map<unknown, unknown>,\n    cloneServiceExecute: CloneServiceExecuteCallback<unknown>,\n  ) {\n    const newMap = new Map(aMap)\n    aMap.forEach((value, key) => newMap.set(key, cloneServiceExecute(value)))\n    return newMap\n  }\n}\n","import { CloneHandler, CloneServiceExecuteCallback } from './clone-handler'\nimport { TypeCheck } from '../shared/type-check'\n\nexport class SetCloneHandler extends CloneHandler {\n  public handle(\n    aType: unknown,\n    cloneServiceExecute: CloneServiceExecuteCallback<unknown>,\n  ): unknown {\n    if (TypeCheck.isSet(aType)) {\n      return this.createCloneOf(aType, cloneServiceExecute)\n    }\n    return this.handleNext(aType, cloneServiceExecute)\n  }\n\n  private createCloneOf(\n    aSet: Set<unknown>,\n    cloneServiceExecute: CloneServiceExecuteCallback<unknown>,\n  ) {\n    const newSet = new Set(aSet)\n    aSet.forEach((value) => newSet.add(cloneServiceExecute(value)))\n    return newSet\n  }\n}\n","import {\n  ArrayCloneHandler,\n  CloneHandler,\n  DateCloneHandler,\n  MapCloneHandler,\n  ObjectCloneHandler,\n  SetCloneHandler,\n} from '../clone-handlers'\n\nexport class CloneService {\n  private static recursivelyHandler?: CloneHandler\n\n  public static execute<TBaseState>(aBaseState: TBaseState): TBaseState {\n    if (!this.recursivelyHandler) {\n      const objectCloneHandler = new ObjectCloneHandler()\n      const arrayCloneHandler = new ArrayCloneHandler(objectCloneHandler)\n      const mapCloneHandler = new MapCloneHandler(arrayCloneHandler)\n      const setCloneHandler = new SetCloneHandler(mapCloneHandler)\n      const dateCloneHandler = new DateCloneHandler(setCloneHandler)\n      this.recursivelyHandler = dateCloneHandler\n    }\n\n    return this.recursivelyHandler.handle(\n      aBaseState,\n      this.execute.bind(this),\n    ) as TBaseState\n  }\n}\n","export type FreezeServiceExecuteCallback<Type> = (baseState: Type) => Type\n\nexport abstract class FreezeHandler<Type = unknown> {\n  private next?: FreezeHandler<Type>\n\n  constructor(aHandler?: FreezeHandler<Type>) {\n    this.next = aHandler\n  }\n\n  public abstract handle(\n    aType: Type,\n    freezeServiceExecute: FreezeServiceExecuteCallback<Type>,\n  ): Type\n\n  protected handleNext(\n    aType: Type,\n    cloneRecursively: FreezeServiceExecuteCallback<Type>,\n  ): Type {\n    if (this.next) {\n      return this.next.handle(aType, cloneRecursively)\n    }\n    return aType\n  }\n\n  protected freeze(aType: Type): Readonly<Type> {\n    return Object.freeze(aType)\n  }\n}\n","import { CloneService } from '../services/clone-service'\nimport { TypeCheck } from '../shared/type-check'\nimport { FreezeHandler, FreezeServiceExecuteCallback } from './freeze-handler'\n\nexport class ArrayFreezeHandler extends FreezeHandler {\n  public handle(\n    aType: unknown,\n    freezeServiceExecute: FreezeServiceExecuteCallback<unknown>,\n  ): unknown {\n    if (TypeCheck.isArray(aType)) {\n      return this.freeze(\n        this.createCloneOf(CloneService.execute(aType), freezeServiceExecute),\n      )\n    }\n    return this.handleNext(aType, freezeServiceExecute)\n  }\n\n  private createCloneOf(\n    aType: unknown[],\n    freezeRecursively: FreezeServiceExecuteCallback<unknown>,\n  ): unknown[] {\n    return aType.map(freezeRecursively)\n  }\n}\n","export class CannotAssignToImmutableMapError extends Error {\n  constructor() {\n    super('Cannot assign to immutable Map')\n    this.name = 'CannotAssignToImmutableMapError'\n  }\n}\n","import { CannotAssignToImmutableMapError } from '../shared/errors/cannot-assign-to-immutable-map-error'\nimport { TypeCheck } from '../shared/type-check'\nimport { FreezeHandler, FreezeServiceExecuteCallback } from './freeze-handler'\n\nexport class MapFreezeHandler extends FreezeHandler {\n  public handle(\n    aType: unknown,\n    freezeServiceExecute: FreezeServiceExecuteCallback<unknown>,\n  ): unknown {\n    if (TypeCheck.isMap(aType)) {\n      return this.freezeMap(aType)\n    }\n    return this.handleNext(aType, freezeServiceExecute)\n  }\n\n  private freezeMap(\n    aMap: Map<unknown, unknown>,\n  ): Readonly<Map<unknown, unknown>> {\n    aMap.set = this.throwError\n    aMap.delete = this.throwError\n    aMap.clear = this.throwError\n    return this.freeze(aMap) as Readonly<Map<unknown, unknown>>\n  }\n\n  private throwError(): never {\n    throw new CannotAssignToImmutableMapError()\n  }\n}\n","import { CloneService } from '../services/clone-service'\nimport { CloneRecursively } from '../shared/clone-recursively'\nimport { TypeCheck } from '../shared/type-check'\nimport { FreezeHandler, FreezeServiceExecuteCallback } from './freeze-handler'\n\nexport class ObjectFreezeHandler extends FreezeHandler {\n  public handle(\n    aType: unknown,\n    freezeServiceExecute: FreezeServiceExecuteCallback<unknown>,\n  ): unknown {\n    if (TypeCheck.isObject(aType)) {\n      return this.freeze(\n        CloneRecursively.execute(\n          CloneService.execute(aType),\n          freezeServiceExecute,\n        ),\n      )\n    }\n    return this.handleNext(aType, freezeServiceExecute)\n  }\n}\n","export class CannotAssignToImmutableSetError extends Error {\n  constructor() {\n    super('Cannot assign to immutable Set')\n    this.name = 'CannotAssignToImmutableSetError'\n  }\n}\n","import { CannotAssignToImmutableSetError } from '../shared/errors/cannot-assign-to-immutable-set-error'\nimport { TypeCheck } from '../shared/type-check'\nimport { FreezeHandler, FreezeServiceExecuteCallback } from './freeze-handler'\n\nexport class SetFreezeHandler extends FreezeHandler {\n  public handle(\n    aType: unknown,\n    freezeServiceExecute: FreezeServiceExecuteCallback<unknown>,\n  ): unknown {\n    if (TypeCheck.isSet(aType)) {\n      return this.freezeSet(aType)\n    }\n    return this.handleNext(aType, freezeServiceExecute)\n  }\n\n  private freezeSet(aSet: Set<unknown>): Readonly<Set<unknown>> {\n    aSet.add = this.throwError\n    aSet.delete = this.throwError\n    aSet.clear = this.throwError\n    return this.freeze(aSet) as Readonly<Set<unknown>>\n  }\n\n  private throwError(): never {\n    throw new CannotAssignToImmutableSetError()\n  }\n}\n","import { CloneService } from './../services/clone-service'\nimport { TypeCheck } from '../shared/type-check'\nimport { FreezeHandler, FreezeServiceExecuteCallback } from './freeze-handler'\n\nexport class DateFreezeHandler extends FreezeHandler {\n  public handle(\n    aType: unknown,\n    freezeServiceExecute: FreezeServiceExecuteCallback<unknown>,\n  ): unknown {\n    if (TypeCheck.isDate(aType)) {\n      return this.freeze(CloneService.execute(aType))\n    }\n    return this.handleNext(aType, freezeServiceExecute)\n  }\n}\n","import {\n  ArrayFreezeHandler,\n  FreezeHandler,\n  MapFreezeHandler,\n  ObjectFreezeHandler,\n  SetFreezeHandler,\n} from '../freeze-handlers'\nimport { DateFreezeHandler } from '../freeze-handlers/date-clone-handler'\n\nexport class FreezeService {\n  private static recursivelyHandler?: FreezeHandler\n\n  public static execute<TBaseState>(aBaseState: TBaseState): TBaseState {\n    if (!this.recursivelyHandler) {\n      const setFreezeHandler = new SetFreezeHandler()\n      const mapFreezeHandler = new MapFreezeHandler(setFreezeHandler)\n      const objectFreezeHandler = new ObjectFreezeHandler(mapFreezeHandler)\n      const arrayFreezeHandler = new ArrayFreezeHandler(objectFreezeHandler)\n      const dateFreezeHandler = new DateFreezeHandler(arrayFreezeHandler)\n      this.recursivelyHandler = dateFreezeHandler\n    }\n\n    return this.recursivelyHandler.handle(\n      aBaseState,\n      this.execute.bind(this),\n    ) as TBaseState\n  }\n}\n","type ProducerCallback<TBaseState> = (draftState: TBaseState) => void\n\nexport class ProduceService {\n  public static execute<TBaseState>(\n    draftState: TBaseState,\n    producer: ProducerCallback<TBaseState>,\n  ) {\n    producer(draftState)\n  }\n}\n","import { CloneService } from './services/clone-service'\r\nimport { FreezeService } from './services/freeze-service'\r\nimport { ProduceService } from './services/produce-service'\r\n\r\ntype Producer<TBaseState> = (draftState: TBaseState) => void\r\ntype ImmuterConfigProps = {\r\n  freeze: boolean\r\n}\r\n\r\nconst initialState: ImmuterConfigProps = {\r\n  freeze: true,\r\n}\r\n\r\nexport class Immuter {\r\n  private static instance = this.createImmutable()\r\n  private constructor(private readonly config: ImmuterConfigProps) {}\r\n\r\n  private static createImmutable(): Immuter {\r\n    return new Immuter(initialState)\r\n  }\r\n\r\n  private static createMutable(): Immuter {\r\n    return new Immuter({\r\n      freeze: false,\r\n    })\r\n  }\r\n\r\n  public static get global() {\r\n    return {\r\n      not: {\r\n        freeze: () => {\r\n          this.instance = this.createMutable()\r\n        },\r\n      },\r\n      freeze: () => {\r\n        this.instance = this.createImmutable()\r\n      },\r\n    }\r\n  }\r\n\r\n  public static get not() {\r\n    return {\r\n      freeze: this.createMutable(),\r\n    }\r\n  }\r\n\r\n  public static produce<TBaseState extends object>(\r\n    aBaseState: TBaseState,\r\n    aProducer: Producer<TBaseState>,\r\n  ) {\r\n    return this.instance.produce(aBaseState, aProducer)\r\n  }\r\n\r\n  public static clone<TBaseState extends object>(\r\n    aBaseState: TBaseState,\r\n  ): TBaseState {\r\n    return this.instance.clone(aBaseState)\r\n  }\r\n\r\n  public clone<TBaseState extends object>(aBaseState: TBaseState): TBaseState {\r\n    const draftState = CloneService.execute(aBaseState)\r\n    return this.execute(draftState)\r\n  }\r\n\r\n  private execute<TBaseState extends object>(\r\n    aDraftState: TBaseState,\r\n  ): TBaseState {\r\n    const result = this.freezeIfNecessary(aDraftState)\r\n    return result\r\n  }\r\n\r\n  private freezeIfNecessary<TBaseState extends object>(\r\n    aDraftState: TBaseState,\r\n  ) {\r\n    return this.config.freeze ? FreezeService.execute(aDraftState) : aDraftState\r\n  }\r\n\r\n  public produce<TBaseState extends object>(\r\n    aBaseState: TBaseState,\r\n    produce: Producer<TBaseState>,\r\n  ): TBaseState {\r\n    const draftState = CloneService.execute(aBaseState)\r\n    ProduceService.execute(draftState, produce)\r\n    return this.execute(draftState)\r\n  }\r\n}\r\n"]}