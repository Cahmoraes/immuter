{"version":3,"sources":["../src/index.ts","../src/immuter/clone-handlers/clone-handler.ts","../src/immuter/shared/type-check.ts","../src/immuter/clone-handlers/array-clone-handler.ts","../src/immuter/clone-handlers/date-clone-handler.ts","../src/immuter/shared/clone-recursively.ts","../src/immuter/clone-handlers/object-clone-handler.ts","../src/immuter/clone-handlers/map-clone-handler.ts","../src/immuter/clone-handlers/set-clone-handler.ts","../src/immuter/services/clone-service.ts","../src/immuter/freeze-handlers/freeze-handler.ts","../src/immuter/freeze-handlers/array-freeze-handler.ts","../src/immuter/shared/errors/cannot-assign-to-immutable-map-error.ts","../src/immuter/freeze-handlers/map-freeze-handler.ts","../src/immuter/freeze-handlers/object-freeze-handler.ts","../src/immuter/shared/errors/cannot-assign-to-immutable-set-error.ts","../src/immuter/freeze-handlers/set-freeze-handler.ts","../src/immuter/freeze-handlers/date-clone-handler.ts","../src/immuter/services/freeze-service.ts","../src/immuter/services/produce-service.ts","../src/immuter/index.ts"],"sourcesContent":["export { Immuter } from './immuter'\n","export type CloneServiceExecuteCallback<Type> = (baseState: Type) => Type\n\nexport abstract class CloneHandler<Type = unknown> {\n  private next?: CloneHandler<Type>\n\n  constructor(aHandler?: CloneHandler<Type>) {\n    this.next = aHandler\n  }\n\n  public abstract handle(\n    aType: Type,\n    cloneServiceExecute: CloneServiceExecuteCallback<Type>,\n  ): Type\n\n  protected handleNext(\n    aType: Type,\n    cloneRecursively: CloneServiceExecuteCallback<Type>,\n  ): Type {\n    if (this.next) {\n      return this.next.handle(aType, cloneRecursively)\n    }\n    return aType\n  }\n}\n","export class TypeCheck {\n  private static check(aType: unknown): string {\n    const typeString = Reflect.apply(Object.prototype.toString, aType, [])\n    return typeString\n      .slice(typeString.indexOf(' ') + 1, typeString.indexOf(']'))\n      .toLowerCase()\n  }\n\n  static isDate(aType: unknown): aType is Date {\n    return this.check(aType) === 'date'\n  }\n\n  static isObject(aType: unknown): aType is object {\n    return this.check(aType) === 'object'\n  }\n\n  static isArray(aType: unknown): aType is unknown[] {\n    return Array.isArray(aType)\n  }\n\n  static isMap(aType: unknown): aType is Map<unknown, unknown> {\n    return this.check(aType) === 'map'\n  }\n\n  static isSet(aType: unknown): aType is Set<unknown> {\n    return this.check(aType) === 'set'\n  }\n}\n","import { CloneHandler, CloneServiceExecuteCallback } from './clone-handler'\nimport { TypeCheck } from '../shared/type-check'\n\nexport class ArrayCloneHandler extends CloneHandler {\n  public handle(\n    aType: unknown,\n    cloneRecursively: CloneServiceExecuteCallback<unknown>,\n  ): unknown {\n    if (TypeCheck.isArray(aType)) {\n      return this.createCloneOf(aType, cloneRecursively)\n    }\n    return this.handleNext(aType, cloneRecursively)\n  }\n\n  private createCloneOf(\n    aType: unknown[],\n    cloneRecursively: CloneServiceExecuteCallback<unknown>,\n  ): unknown[] {\n    return aType.map(cloneRecursively)\n  }\n}\n","import { CloneHandler, CloneServiceExecuteCallback } from './clone-handler'\nimport { TypeCheck } from '../shared/type-check'\n\nexport class DateCloneHandler extends CloneHandler {\n  public handle<TBaseState>(\n    aType: TBaseState,\n    cloneRecursively: CloneServiceExecuteCallback<unknown>,\n  ) {\n    if (TypeCheck.isDate(aType)) {\n      return new Date(aType)\n    }\n    return this.handleNext(aType, cloneRecursively)\n  }\n}\n","type CloneServiceExecuteCallback<Type> = (baseState: Type) => Type\n\ntype TypedPropertyDescriptorOf<TBaseState> = {\n  [P in keyof TBaseState]: TypedPropertyDescriptor<TBaseState[P]>\n} & {\n  [x: string]: PropertyDescriptor\n}\n\nexport class CloneRecursively {\n  public static execute(\n    aBaseStateCloned: object,\n    strategyRecursively: CloneServiceExecuteCallback<unknown>,\n  ) {\n    return this.performClone(aBaseStateCloned, strategyRecursively)\n  }\n\n  private static performClone(\n    aBaseStateCloned: object,\n    aStrategyRecursively: CloneServiceExecuteCallback<unknown>,\n  ) {\n    const objectToClone = this.createCloneOf(aBaseStateCloned)\n    const descriptors = this.propertyDescriptorsOf(aBaseStateCloned)\n    for (const descriptor of Reflect.ownKeys(descriptors)) {\n      if (this.isEligibleToAssign(descriptors, descriptor)) {\n        objectToClone[descriptor] = aStrategyRecursively(\n          Reflect.get(objectToClone, descriptor),\n        )\n      }\n    }\n    return objectToClone\n  }\n\n  private static createCloneOf<TBaseState>(aBaseState: TBaseState) {\n    return Object.create(\n      this.prototypeOf(aBaseState),\n      this.propertyDescriptorsOf(aBaseState),\n    )\n  }\n\n  private static prototypeOf<TBaseState>(aBaseState: TBaseState) {\n    return Object.getPrototypeOf(aBaseState)\n  }\n\n  private static propertyDescriptorsOf<TBaseState>(aBaseState: TBaseState) {\n    return Object.getOwnPropertyDescriptors(aBaseState)\n  }\n\n  private static isEligibleToAssign<TBaseState>(\n    descriptors: TypedPropertyDescriptorOf<TBaseState>,\n    descriptor: keyof TBaseState | string | symbol,\n  ): descriptor is keyof TBaseState {\n    return (\n      descriptors[String(descriptor)] &&\n      Reflect.has(descriptors[String(descriptor)], 'value')\n    )\n  }\n}\n","import { CloneHandler, CloneServiceExecuteCallback } from './clone-handler'\nimport { TypeCheck } from '../shared/type-check'\nimport { CloneRecursively } from '../shared/clone-recursively'\n\nexport class ObjectCloneHandler extends CloneHandler {\n  public handle(\n    aType: unknown,\n    cloneServiceExecute: CloneServiceExecuteCallback<unknown>,\n  ) {\n    if (TypeCheck.isObject(aType)) {\n      return CloneRecursively.execute(aType, cloneServiceExecute)\n    }\n    return this.handleNext(aType, cloneServiceExecute)\n  }\n}\n","import { CloneHandler, CloneServiceExecuteCallback } from './clone-handler'\nimport { TypeCheck } from '../shared/type-check'\n\nexport class MapCloneHandler extends CloneHandler {\n  public handle(\n    aType: unknown,\n    cloneServiceExecute: CloneServiceExecuteCallback<unknown>,\n  ): unknown {\n    if (TypeCheck.isMap(aType)) {\n      return this.createCloneOf(aType, cloneServiceExecute)\n    }\n    return this.handleNext(aType, cloneServiceExecute)\n  }\n\n  private createCloneOf(\n    aMap: Map<unknown, unknown>,\n    cloneServiceExecute: CloneServiceExecuteCallback<unknown>,\n  ) {\n    const newMap = new Map(aMap)\n    aMap.forEach((value, key) => newMap.set(key, cloneServiceExecute(value)))\n    return newMap\n  }\n}\n","import { CloneHandler, CloneServiceExecuteCallback } from './clone-handler'\nimport { TypeCheck } from '../shared/type-check'\n\nexport class SetCloneHandler extends CloneHandler {\n  public handle(\n    aType: unknown,\n    cloneServiceExecute: CloneServiceExecuteCallback<unknown>,\n  ): unknown {\n    if (TypeCheck.isSet(aType)) {\n      return this.createCloneOf(aType, cloneServiceExecute)\n    }\n    return this.handleNext(aType, cloneServiceExecute)\n  }\n\n  private createCloneOf(\n    aSet: Set<unknown>,\n    cloneServiceExecute: CloneServiceExecuteCallback<unknown>,\n  ) {\n    const newSet = new Set(aSet)\n    aSet.forEach((value) => newSet.add(cloneServiceExecute(value)))\n    return newSet\n  }\n}\n","import {\n  ArrayCloneHandler,\n  CloneHandler,\n  DateCloneHandler,\n  MapCloneHandler,\n  ObjectCloneHandler,\n  SetCloneHandler,\n} from '../clone-handlers'\n\nexport class CloneService {\n  private static recursivelyHandler?: CloneHandler\n\n  public static execute<TBaseState>(aBaseState: TBaseState): TBaseState {\n    if (!this.recursivelyHandler) {\n      const objectCloneHandler = new ObjectCloneHandler()\n      const arrayCloneHandler = new ArrayCloneHandler(objectCloneHandler)\n      const mapCloneHandler = new MapCloneHandler(arrayCloneHandler)\n      const setCloneHandler = new SetCloneHandler(mapCloneHandler)\n      const dateCloneHandler = new DateCloneHandler(setCloneHandler)\n      this.recursivelyHandler = dateCloneHandler\n    }\n\n    return this.recursivelyHandler.handle(\n      aBaseState,\n      this.execute.bind(this),\n    ) as TBaseState\n  }\n}\n","export type FreezeServiceExecuteCallback<Type> = (baseState: Type) => Type\n\nexport abstract class FreezeHandler<Type = unknown> {\n  private next?: FreezeHandler<Type>\n\n  constructor(aHandler?: FreezeHandler<Type>) {\n    this.next = aHandler\n  }\n\n  public abstract handle(\n    aType: Type,\n    freezeServiceExecute: FreezeServiceExecuteCallback<Type>,\n  ): Type\n\n  protected handleNext(\n    aType: Type,\n    cloneRecursively: FreezeServiceExecuteCallback<Type>,\n  ): Type {\n    if (this.next) {\n      return this.next.handle(aType, cloneRecursively)\n    }\n    return aType\n  }\n\n  protected freeze(aType: Type): Readonly<Type> {\n    return Object.freeze(aType)\n  }\n}\n","import { CloneService } from '../services/clone-service'\nimport { TypeCheck } from '../shared/type-check'\nimport { FreezeHandler, FreezeServiceExecuteCallback } from './freeze-handler'\n\nexport class ArrayFreezeHandler extends FreezeHandler {\n  public handle(\n    aType: unknown,\n    freezeServiceExecute: FreezeServiceExecuteCallback<unknown>,\n  ): unknown {\n    if (TypeCheck.isArray(aType)) {\n      return this.freeze(\n        this.createCloneOf(CloneService.execute(aType), freezeServiceExecute),\n      )\n    }\n    return this.handleNext(aType, freezeServiceExecute)\n  }\n\n  private createCloneOf(\n    aType: unknown[],\n    freezeRecursively: FreezeServiceExecuteCallback<unknown>,\n  ): unknown[] {\n    return aType.map(freezeRecursively)\n  }\n}\n","export class CannotAssignToImmutableMapError extends Error {\n  constructor() {\n    super('Cannot assign to immutable Map')\n    this.name = 'CannotAssignToImmutableMapError'\n  }\n}\n","import { CannotAssignToImmutableMapError } from '../shared/errors/cannot-assign-to-immutable-map-error'\nimport { TypeCheck } from '../shared/type-check'\nimport { FreezeHandler, FreezeServiceExecuteCallback } from './freeze-handler'\n\nexport class MapFreezeHandler extends FreezeHandler {\n  public handle(\n    aType: unknown,\n    freezeServiceExecute: FreezeServiceExecuteCallback<unknown>,\n  ): unknown {\n    if (TypeCheck.isMap(aType)) {\n      return this.freezeMap(aType)\n    }\n    return this.handleNext(aType, freezeServiceExecute)\n  }\n\n  private freezeMap(\n    aMap: Map<unknown, unknown>,\n  ): Readonly<Map<unknown, unknown>> {\n    aMap.set = this.throwError\n    aMap.delete = this.throwError\n    aMap.clear = this.throwError\n    return this.freeze(aMap) as Readonly<Map<unknown, unknown>>\n  }\n\n  private throwError(): never {\n    throw new CannotAssignToImmutableMapError()\n  }\n}\n","import { CloneService } from '../services/clone-service'\nimport { CloneRecursively } from '../shared/clone-recursively'\nimport { TypeCheck } from '../shared/type-check'\nimport { FreezeHandler, FreezeServiceExecuteCallback } from './freeze-handler'\n\nexport class ObjectFreezeHandler extends FreezeHandler {\n  public handle(\n    aType: unknown,\n    freezeServiceExecute: FreezeServiceExecuteCallback<unknown>,\n  ): unknown {\n    if (TypeCheck.isObject(aType)) {\n      return this.freeze(\n        CloneRecursively.execute(\n          CloneService.execute(aType),\n          freezeServiceExecute,\n        ),\n      )\n    }\n    return this.handleNext(aType, freezeServiceExecute)\n  }\n}\n","export class CannotAssignToImmutableSetError extends Error {\n  constructor() {\n    super('Cannot assign to immutable Set')\n    this.name = 'CannotAssignToImmutableSetError'\n  }\n}\n","import { CannotAssignToImmutableSetError } from '../shared/errors/cannot-assign-to-immutable-set-error'\nimport { TypeCheck } from '../shared/type-check'\nimport { FreezeHandler, FreezeServiceExecuteCallback } from './freeze-handler'\n\nexport class SetFreezeHandler extends FreezeHandler {\n  public handle(\n    aType: unknown,\n    freezeServiceExecute: FreezeServiceExecuteCallback<unknown>,\n  ): unknown {\n    if (TypeCheck.isSet(aType)) {\n      return this.freezeSet(aType)\n    }\n    return this.handleNext(aType, freezeServiceExecute)\n  }\n\n  private freezeSet(aSet: Set<unknown>): Readonly<Set<unknown>> {\n    aSet.add = this.throwError\n    aSet.delete = this.throwError\n    aSet.clear = this.throwError\n    return this.freeze(aSet) as Readonly<Set<unknown>>\n  }\n\n  private throwError(): never {\n    throw new CannotAssignToImmutableSetError()\n  }\n}\n","import { CloneService } from './../services/clone-service'\nimport { TypeCheck } from '../shared/type-check'\nimport { FreezeHandler, FreezeServiceExecuteCallback } from './freeze-handler'\n\nexport class DateFreezeHandler extends FreezeHandler {\n  public handle(\n    aType: unknown,\n    freezeServiceExecute: FreezeServiceExecuteCallback<unknown>,\n  ): unknown {\n    if (TypeCheck.isDate(aType)) {\n      return this.freeze(CloneService.execute(aType))\n    }\n    return this.handleNext(aType, freezeServiceExecute)\n  }\n}\n","import {\n  ArrayFreezeHandler,\n  FreezeHandler,\n  MapFreezeHandler,\n  ObjectFreezeHandler,\n  SetFreezeHandler,\n} from '../freeze-handlers'\nimport { DateFreezeHandler } from '../freeze-handlers/date-clone-handler'\n\nexport class FreezeService {\n  private static recursivelyHandler?: FreezeHandler\n\n  public static execute<TBaseState>(aBaseState: TBaseState): TBaseState {\n    if (!this.recursivelyHandler) {\n      const setFreezeHandler = new SetFreezeHandler()\n      const mapFreezeHandler = new MapFreezeHandler(setFreezeHandler)\n      const objectFreezeHandler = new ObjectFreezeHandler(mapFreezeHandler)\n      const arrayFreezeHandler = new ArrayFreezeHandler(objectFreezeHandler)\n      const dateFreezeHandler = new DateFreezeHandler(arrayFreezeHandler)\n      this.recursivelyHandler = dateFreezeHandler\n    }\n\n    return this.recursivelyHandler.handle(\n      aBaseState,\n      this.execute.bind(this),\n    ) as TBaseState\n  }\n}\n","type ProducerCallback<TBaseState> = (draftState: TBaseState) => void\n\nexport class ProduceService {\n  public static execute<TBaseState>(\n    draftState: TBaseState,\n    producer: ProducerCallback<TBaseState>,\n  ) {\n    producer(draftState)\n  }\n}\n","import { CloneService } from './services/clone-service'\nimport { FreezeService } from './services/freeze-service'\nimport { ProduceService } from './services/produce-service'\n\ntype Produce<TBaseState> = (draftState: TBaseState) => void\n\nexport type ImmuterConfig = {\n  freeze: boolean\n}\n\nexport class Immuter {\n  private static config: ImmuterConfig = {\n    freeze: true,\n  }\n\n  public static get not() {\n    return {\n      freeze: this.setFreeze(false),\n    }\n  }\n\n  private static setFreeze(aBoolean: boolean) {\n    this.config.freeze = aBoolean\n    return {\n      clone: this.clone.bind(this),\n      produce: this.produce.bind(this),\n    }\n  }\n\n  public static clone<TBaseState extends object>(\n    aBaseState: TBaseState,\n  ): TBaseState {\n    const draftState = CloneService.execute(aBaseState)\n    return this.execute(draftState)\n  }\n\n  private static execute<TBaseState extends object>(\n    aDraftState: TBaseState,\n  ): TBaseState {\n    const result = this.freezeIfNecessary(aDraftState)\n    Immuter.resetConfig()\n    return result\n  }\n\n  private static freezeIfNecessary<TBaseState extends object>(\n    aDraftState: TBaseState,\n  ) {\n    return Immuter.config.freeze\n      ? FreezeService.execute(aDraftState)\n      : aDraftState\n  }\n\n  private static resetConfig() {\n    this.config.freeze = true\n  }\n\n  public static produce<TBaseState extends object>(\n    aBaseState: TBaseState,\n    produce: Produce<TBaseState>,\n  ): TBaseState {\n    const draftState = CloneService.execute(aBaseState)\n    ProduceService.execute(draftState, produce)\n    return this.execute(draftState)\n  }\n}\n"],"mappings":"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","names":["src_exports","__export","Immuter","__toCommonJS","CloneHandler","aHandler","aType","cloneRecursively","TypeCheck","aType","typeString","ArrayCloneHandler","CloneHandler","aType","cloneRecursively","TypeCheck","DateCloneHandler","CloneHandler","aType","cloneRecursively","TypeCheck","CloneRecursively","aBaseStateCloned","strategyRecursively","aStrategyRecursively","objectToClone","descriptors","descriptor","aBaseState","ObjectCloneHandler","CloneHandler","aType","cloneServiceExecute","TypeCheck","CloneRecursively","MapCloneHandler","CloneHandler","aType","cloneServiceExecute","TypeCheck","aMap","newMap","value","key","SetCloneHandler","CloneHandler","aType","cloneServiceExecute","TypeCheck","aSet","newSet","value","CloneService","aBaseState","objectCloneHandler","ObjectCloneHandler","arrayCloneHandler","ArrayCloneHandler","mapCloneHandler","MapCloneHandler","setCloneHandler","SetCloneHandler","dateCloneHandler","DateCloneHandler","FreezeHandler","aHandler","aType","cloneRecursively","ArrayFreezeHandler","FreezeHandler","aType","freezeServiceExecute","TypeCheck","CloneService","freezeRecursively","CannotAssignToImmutableMapError","MapFreezeHandler","FreezeHandler","aType","freezeServiceExecute","TypeCheck","aMap","CannotAssignToImmutableMapError","ObjectFreezeHandler","FreezeHandler","aType","freezeServiceExecute","TypeCheck","CloneRecursively","CloneService","CannotAssignToImmutableSetError","SetFreezeHandler","FreezeHandler","aType","freezeServiceExecute","TypeCheck","aSet","CannotAssignToImmutableSetError","DateFreezeHandler","FreezeHandler","aType","freezeServiceExecute","TypeCheck","CloneService","FreezeService","aBaseState","setFreezeHandler","SetFreezeHandler","mapFreezeHandler","MapFreezeHandler","objectFreezeHandler","ObjectFreezeHandler","arrayFreezeHandler","ArrayFreezeHandler","dateFreezeHandler","DateFreezeHandler","ProduceService","draftState","producer","_Immuter","aBoolean","aBaseState","draftState","CloneService","aDraftState","result","FreezeService","produce","ProduceService","Immuter"]}